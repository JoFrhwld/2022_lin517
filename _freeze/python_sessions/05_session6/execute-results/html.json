{
  "hash": "7b2566d6b7048b20a0a6af481b0dbd9e",
  "result": {
    "markdown": "---\ntitle: \"Functions\"\neditor: visual\nauthor: Josef Fruehwald\ndate: 2022-10-14\nformat: \n  html: default\n---\n\n## Writing your own functions\n\nSo far, we've been using either built in python functions, like `len()` or `print()`, or functions provided by other packages, like `nltk.word_tokenize()`.\n\nBut, we can also write our *own* functions. It is super useful to write our own functions so that we can save on retyping code, and to ensure we carry out the same exact operations every time.\n\n## Example - Counting tokens in a book\n\n### Without our own function\n\nIf we wanted to count the number of tokens in a book, we could write out some code like so:\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport nltk\n```\n:::\n\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\npath = \"gen/texts/frank.txt\"\nwith open(path, 'r') as f:\n  text = f.read()\ntokens = nltk.word_tokenize(text)\nn_tokens = len(tokens)\nn_types = len(set(tokens))\ntype_token_dict = {\"tokens\" : n_tokens,\n                   \"types\" : n_types}\n```\n:::\n\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\ntype_token_dict\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n{'tokens': 85324, 'types': 7710}\n```\n:::\n:::\n\n\nNow, if we wanted to do the same thing all over again with a different book, say *Voyage to the Center of the Earth*, we'd have to copy-paste our code, and maybe even change the variable names. Instead we can rewrite this code as a *function*.\n\n### Writing a function\n\nTo write your own function, you need to plan on what kind of *inputs* you want to use to get specific *outputs*. A simple function in python looks like this.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\ndef repeat_string(input_string, n):\n  \"\"\"\n    Repeat the input_string n times\n  \"\"\"\n  output_string = [input_string] * n\n  return(output_string)\n\n```\n:::\n\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nrepeat_string(input_string = \"hello\", n = 5)\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n['hello', 'hello', 'hello', 'hello', 'hello']\n```\n:::\n:::\n\n\nLet's briefly pick apart each line\n\n#### The definition line\n\n``` python\ndef repeat_string(input_string, n):\n```\n\nThis line *defines* (hence the `def` part) the new function. After running this whole block of code, when we type in `repeat_string`, python is going to interpret it as referring to this function (a lot like how variable assignment works).\n\nWhatever we type in after `def` is going to be the name of our new function. The restrictions on what we name functions are the same as for variables.\n\nInside the parentheses are the variables the function *will* use. This is a lot like how we declare temporary variables in a for loop, and then use that variable inside the for loop.\n\n::: callout-note\n## Naming Recommendation\n\nI'm going to make the following recommendations about function naming:\n\n-   name your functions in lower case.\n\n-   use underscores `_` to separate words (you *can't* use dots `.` or dashes `-`)\n\n-   make the first word in your function word an imperative verb. some good options are going to be\n\n    -   `get_`\n\n    -   `calculate_`\n\n    -   `make_`\n\n-   name the whole function for what it *does*.\n\n    -   `calculate_conditional_prob()`\n\n    -   `convert_prob_to_surprisal()`\n\n    -   `get_book()`\n:::\n\n#### The \"docstring\"\n\nImmediately after the definition line, (and indented once), include a brief description of what the function does, marked out by three `\"`.\n\n``` python\n  \"\"\"\n    Repeat the input_string n times\n  \"\"\"\n```\n\nThis is important for 2 reasons:\n\n1.  Explaining your code to other people.\n2.  Explaining your code to yourself, in the future (who is effectively another person).\n\nThere are also a lot of python systems that automatically extract docstrings from python scripts to build whole documentation pages.\n\n#### The function block\n\nNow, we have the main part of the function: the code that does stuff.\n\n``` python\n  output_string = [input_string] * n\n```\n\nInside this function block, we can call upon the temporary variables we defined in the definition line, and any other function, including functions from the standard library, functions we've imported, or any other function we've written.\n\nWe can also create and modify any variables we want inside the function. But note, they're going to stay locked away inside the function, and we won't be able to call upon them in other parts of our scripts.\n\n#### The return statement\n\nOnce we've done some stuff inside the function, we'll usually want it to have something to show for its work. This is where the `return()` statement comes in. This is where the function returns some kind of output for us to work on in the rest of the script.\n\n``` python\n  return(output_string)\n```\n\n#### Planning for writing a function\n\nThink about writing a function like packing for a trip. You need to plan for what you're going to bring with you, and while you're away, you won't be able access anything you didn't bring along. Then, at the end of the trip, you can come home with a souvenir!\n\nFor example, let's write another function that prints out the output of the previous `repeat_string()` function where we forget to pack something.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\ndef print_repetition(input_string):\n  \"\"\"\n    print the input string n times\n    This function doesn't return() anything, and that's ok\n  \"\"\"\n  rep_list = repeat_string(input_string, n = n)\n  for item in rep_list:\n    print(item)\n\nprint_repetition(\"hello!\")\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'n' is not defined\n```\n:::\n:::\n\n\nAh! In the `def` line, we forgot to pack `n`! Even if we try to pass an argument `n` to the function, it won't know what to do with it.\n\n### Writing the type & token function\n\nAs a reminder, here's the code we used before to read in `frank.txt` and return a dictionary of\n\n``` python\npath = \"gen/texts/frank.txt\"\nwith open(path, 'r') as f:\n  text = f.read()\ntokens = nltk.word_tokenize(text)\nn_tokens = len(tokens)\nn_types = len(set(tokens))\ntype_token_dict = {\"tokens\" : n_tokens,\n                   \"types\" : n_types}\n```\n\nLet's turn this into a function.\n\n#### What are we \"packing on our trip\"?\n\nOr, what are our \"inputs\" to the function. We have a few different possible answers here.\n\n1.  We could decide to start with the `path` string. In that case, we'd tell our function to go read in the file as the first step. The only downside here is we wouldn't have access to the file text at the end, just whatever the function `returns()`\n2.  We could decide to start with the `text` string. That means outside of the function, we'd have to do the opening and reading of the function.\n\nLet's decide on starting on the `path` string.\n\n#### What are we bringing home as a souvenir?\n\nThis is a little easier to answer: our target is the `type_token_dict` dictionary.\n\n#### The actual function!\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\ndef get_type_token(path):\n  \"\"\"\n    Read in a file from path, and return a dictionary of type and token counts.\n  \"\"\"\n  with open(path, 'r') as f:\n    text = f.read()\n  tokens = nltk.word_tokenize(text)\n  n_tokens = len(tokens)\n  n_types = len(set(tokens))\n  type_token_dict = {\"tokens\" : n_tokens,\n                     \"types\" : n_types}\n  return(type_token_dict)\n```\n:::\n\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nget_type_token(path = \"gen/texts/frank.txt\")\nget_type_token(path = \"gen/texts/voyage.txt\")\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n{'tokens': 102356, 'types': 8439}\n```\n:::\n:::\n\n\n## The task!\n\nAll of these tasks are asking you to reuse code from the Making and Counting Bigrams project, but to turn them into functions.\n\n::: callout-note\n## Task 1\n\nWrite a function that takes as input a file path, and returns the tokenized and padded sentences as a flat list.\n\n``` python\ndef read_in_tokens(path):\n  \"\"\"\n    Given a path, this returns the tokenized book, with sentences padded out for bigrams\n  \"\"\"\n  \n  ## Things here!\n  return()\n```\n:::\n\n::: callout-note\n## Task 2\n\nWrite a function that takes tokenized and padded text, and returns counts of bigrams.\n\n``` python\ndef make_bigram_counts(tokens):\n  \"\"\"\n    Given a list of tokens, this returns the count of bigrams\n  \"\"\"\n  \n  ## Things here\n  return()\n```\n:::\n\n::: callout-note\n## Task 3\n\nWrite a function that takes a tokenized and padded text, and returns counts of unigrams.\n\n``` python\ndef make_bigram_counts(tokens):\n  \"\"\"\n    Given a list of tokens, this returns the count of unigrams\n  \"\"\"\n  \n  return()\n```\n:::\n\n::: callout-note\n## Task 4\n\nWrite a function that if given a sequence of words `w1` and `w2`, and bigram & unigram counts, will return the conditional probability of P(w2 \\| w1).\n\n**NOTE**: A simplified way to get the conditional probability of P(w2 \\| w1) is to get just the count of the bigram (w1, w2) and divide it by the count of the unigram (w1).\n\n``` python\ndef calculate_conditional_probability(w1, w2, bigram_count, unigram_coint):\n  \"\"\"\n    Given a sequence of words, w1 and w2, as well as bigram and unigram counts, this\n    returns the conditional probability of P(w2 | w1)\n  \"\"\"\n  ## Stuff here\n  return()\n```\n:::\n\n### Tips for doing these tasks\n\n#### Test by doing\n\nThe best way to test if your function is working is to try it out on things! Just try running and rerunning your function to see what it outputs and see if it looks like you were expecting.\n\n#### Build it up\n\nRather than try writing a function that works **and** does what you want it to do in one go, try building it up by writing a function that works but **doesn't** do what you want it to do. Then slowly iterate and try adjusting your function until you get to the output you're looking for.\n\n",
    "supporting": [
      "05_session6_files"
    ],
    "filters": [],
    "includes": {}
  }
}